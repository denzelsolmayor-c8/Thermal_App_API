from fastapi import APIRouter, Depends, HTTPException
from pydantic import BaseModel
from typing import List, Dict, Any

from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.dialects.postgresql import insert as pg_insert
from sqlalchemy import select

from database import Base, get_async_session

router = APIRouter()


class SheetData(BaseModel):
    sheet_name: str
    headers: List[str]
    data: List[List[Any]]
    created_at: str


class UploadPayload(BaseModel):
    id: str
    filename: str
    sheets: List[SheetData]


def get_model_mapping():
    """
    Returns a dictionary mapping table names to their SQLAlchemy models.
    """
    return {
        "mlc_camera_configs": Base.classes.mlc_camera_configs,
        "mlc_camera_presets": Base.classes.mlc_camera_presets,
        "mlc_zones": Base.classes.mlc_zones,
        "mlc_customer": Base.classes.mlc_customer,
        "mlc_temperatures": Base.classes.mlc_temperatures,
    }


# Define the order of insertion for tables to respect foreign key dependencies.
# mlc_camera_presets and mlc_temperatures will be handled separately due to
# their interdependency and the need to retrieve auto-generated IDs.
insert_order_initial = [
    "mlc_zones",
    "mlc_customer",
    "mlc_camera_configs",
]


@router.post("/api/upload-file-data")
async def upload_file_data(
    payload: UploadPayload,
    session: AsyncSession = Depends(get_async_session)
):
    """
    Uploads file data from a payload into various database tables.
    It handles dependencies between tables, specifically resolving
    preset_id for mlc_temperatures after mlc_camera_presets are committed.
    """
    models = get_model_mapping()
    # Initialize a dictionary to store parsed data for each table
    result: Dict[str, List[Dict[str, Any]]] = {name: [] for name in models}

    # Store mlc_temperatures entries temporarily with the 'preset_number'
    # from the input row to resolve preset_id later.
    temp_temperatures_data: List[Dict[str, Any]] = []

    # 1) COLUMN-BASED ROUTING: for each row, try to match it to each table
    for sheet in payload.sheets:
        print(
            f"[DEBUG] Processing sheet: {sheet.sheet_name} with {len(sheet.data)} rows")
        for row in sheet.data:
            row_dict = dict(zip(sheet.headers, row))

            # Skip rows with "alarm" in description, as per existing logic
            desc = row_dict.get("description", "")
            if isinstance(desc, str) and "alarm" in desc.lower():
                continue

            for table_name, model in models.items():
                cols = set(model.__table__.columns.keys())
                # Exclude autogenerated columns (PKs, timestamps) for initial matching
                non_auto = cols - {"rel_id", "id", "created_at", "updated_at"}

                # Special handling for mlc_temperatures:
                # We need 'preset_number' from the input row to link to mlc_camera_presets.
                if table_name == "mlc_temperatures":
                    # Create an entry with only columns relevant to the mlc_temperatures table
                    current_temp_entry = {k: v for k,
                                          v in row_dict.items() if k in cols}

                    # Get the preset_number from the input row for lookup
                    preset_number_from_input = row_dict.get("preset_number")

                    if preset_number_from_input is None:
                        print(
                            f"[WARNING] Skipping temperature entry due to missing 'preset_number' for lookup: {row_dict}")
                        continue

                    try:
                        # Store this 'preset_number' as integer for later lookup
                        current_temp_entry["preset_number_for_lookup"] = int(
                            preset_number_from_input)
                    except (ValueError, TypeError):
                        print(
                            f"[WARNING] Skipping temperature entry due to invalid 'preset_number' (cannot convert to int) for lookup: '{preset_number_from_input}'. Row: {row_dict}")
                        continue

                    # Handle point_in_preset conversion for the mlc_temperatures table itself
                    if "point_in_preset" in current_temp_entry:
                        try:
                            current_temp_entry["point_in_preset"] = int(
                                current_temp_entry["point_in_preset"])
                        except (ValueError, TypeError):
                            print(
                                f"[WARNING] Invalid 'point_in_preset' for mlc_temperatures entry (cannot convert to int): '{current_temp_entry.get('point_in_preset')}'. Row: {row_dict}")
                            # If conversion fails, you might want to set it to None or skip the entry entirely
                            # For now, we'll just log and keep the original value (or None if it was invalid)
                            # Or handle as per your data requirements
                            current_temp_entry["point_in_preset"] = None

                    temp_temperatures_data.append(current_temp_entry)
                    continue  # Skip adding to 'result' for now, handled separately

                # Create an entry with only columns relevant to the current table
                entry = {k: v for k, v in row_dict.items() if k in cols}

                # Check if all non-auto-generated columns required by the model are present in the row
                if non_auto.issubset(entry.keys()):
                    result[table_name].append(entry)
                else:
                    missing = non_auto - entry.keys()
                    if row_dict:  # only log non-empty rows
                        print(
                            f"[SKIP] Row for table '{table_name}' missing required fields: {missing}. Row: {row_dict}")

    print("[DEBUG] Prepared insert counts (initial pass):", {
          k: len(v) for k, v in result.items()})

    try:
        # 2) BULK INSERT tables in initial dependency order
        for table_name in insert_order_initial:
            entries = result.get(table_name)
            if not entries:
                print(
                    f"[DEBUG] Skipping insert for '{table_name}' â€” no entries.")
                continue
            model = models[table_name]

            try:
                stmt = pg_insert(model).values(
                    entries).on_conflict_do_nothing()
                await session.execute(stmt)
                print(
                    f"[DEBUG] Inserted into '{table_name}': {len(entries)} rows")
            except Exception as exc:
                print(f"[ERROR] {table_name} bulk insert failed:", exc)
                raise HTTPException(
                    500, f"Database insert failed for {table_name}: {exc}")

        # 3) Handle mlc_camera_presets: Insert and then commit to get IDs
        mlc_camera_presets_entries = result.get("mlc_camera_presets")
        if mlc_camera_presets_entries:
            model = models["mlc_camera_presets"]
            # Ensure preset_number is int before insert
            for e in mlc_camera_presets_entries:
                if "preset_number" in e:
                    try:
                        e["preset_number"] = int(e["preset_number"])
                    except (ValueError, TypeError):
                        print(
                            f"[WARNING] Invalid preset_number for camera preset entry: {e.get('preset_number')}. Skipping entry.")
                        continue  # Skip this entry if preset_number is invalid

            try:
                # Use returning() to get the generated 'id' for newly inserted rows
                stmt = pg_insert(model).values(mlc_camera_presets_entries).on_conflict_do_nothing(
                    index_elements=['camera_id', 'zone_id', 'preset_number']
                ).returning(model.id, model.camera_id, model.zone_id, model.preset_number)

                # Execute and fetch results
                inserted_presets = await session.execute(stmt)

                # Commit immediately to make IDs available for mlc_temperatures and for subsequent queries
                await session.commit()
                print(
                    f"[DEBUG] Inserted and committed mlc_camera_presets: {len(mlc_camera_presets_entries)} rows (new or existing)")

                # Build a lookup map for preset_id using ONLY preset_number as key
                preset_id_map = {}
                # Collect all unique preset numbers from the input data to query for existing presets
                all_preset_numbers_in_input = {int(e.get(
                    'preset_number')) for e in mlc_camera_presets_entries if e.get('preset_number') is not None}

                # Fetch all relevant presets (inserted or pre-existing) that match any preset_number from the input
                if all_preset_numbers_in_input:
                    existing_presets_query = select(model.id, model.preset_number).filter(
                        model.preset_number.in_(
                            list(all_preset_numbers_in_input))
                    )
                    existing_presets_result = await session.execute(existing_presets_query)
                    for p_id, p_num in existing_presets_result:
                        if p_num in preset_id_map:
                            print(f"[WARNING] Duplicate preset_number '{p_num}' found in mlc_camera_presets. "
                                  f"Overwriting preset_id from {preset_id_map[p_num]} to {p_id}. "
                                  f"Consider if preset_number should be unique or if a different lookup key is needed.")
                        preset_id_map[p_num] = p_id

                print(
                    f"[DEBUG] Built preset_id_map with {len(preset_id_map)} entries (using preset_number as key).")

                # 4) Handle mlc_temperatures: Populate preset_id and insert
                mlc_temperatures_to_insert = []
                for temp_entry in temp_temperatures_data:
                    preset_number_for_lookup = temp_entry.get(
                        "preset_number_for_lookup")

                    if preset_number_for_lookup is not None:
                        preset_id = preset_id_map.get(preset_number_for_lookup)
                        if preset_id:
                            # Add the actual preset_id to the entry
                            temp_entry["preset_id"] = preset_id

                            # Remove temporary lookup key before inserting
                            temp_entry.pop("preset_number_for_lookup", None)

                            mlc_temperatures_to_insert.append(temp_entry)
                        else:
                            print(
                                f"[WARNING] Could not find preset_id for temperature entry with preset_number: {preset_number_for_lookup}. Original temp entry: {temp_entry}")
                    else:
                        print(
                            f"[WARNING] Missing 'preset_number_for_lookup' for temperature entry: {temp_entry}")

                if mlc_temperatures_to_insert:
                    model = models["mlc_temperatures"]
                    try:
                        stmt = pg_insert(model).values(
                            mlc_temperatures_to_insert).on_conflict_do_nothing()
                        await session.execute(stmt)
                        await session.commit()  # Commit temperatures
                        print(
                            f"[DEBUG] Inserted and committed mlc_temperatures: {len(mlc_temperatures_to_insert)} rows")
                    except Exception as exc:
                        print(
                            f"[ERROR] mlc_temperatures bulk insert failed:", exc)
                        raise HTTPException(
                            500, f"Database insert failed for mlc_temperatures: {exc}")
                else:
                    print(
                        "[DEBUG] No mlc_temperatures to insert after resolving preset_ids.")

            except Exception as exc:
                await session.rollback()
                print(f"[ERROR] mlc_camera_presets insert/commit failed:", exc)
                raise HTTPException(
                    500, f"Database operation failed for mlc_camera_presets: {exc}")
        else:
            print("[DEBUG] No mlc_camera_presets to insert.")
            # If no presets, then no temperatures can be linked
            print("[DEBUG] No mlc_temperatures to insert as there are no presets.")

    except HTTPException as e:
        # Re-raise HTTPExceptions directly
        raise e
    except Exception as exc:
        # Catch any other unexpected errors and rollback
        await session.rollback()
        print(f"[ERROR] An unexpected error occurred: {exc}")
        raise HTTPException(
            500, f"An unexpected error occurred during upload: {exc}")

    return {
        "message": "Upload complete",
        "record_count": {
            t: len(result.get(t, [])) for t in insert_order_initial
        } | {
            "mlc_camera_presets": len(result.get("mlc_camera_presets", [])),
            # Report original count attempted for temperatures
            "mlc_temperatures": len(temp_temperatures_data)
        }
    }
